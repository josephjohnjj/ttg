[1/2] Building CXX object examples/CMakeFiles/uts-parsec.dir/uts/uts.cc.o
FAILED: examples/CMakeFiles/uts-parsec.dir/uts/uts.cc.o 
/usr/bin/g++ -DBOOST_ALL_NO_LIB -DBOOST_SERIALIZATION_DYN_LINK -DMADNESS_MPI_HEADER=\"/usr/local/include/mpi.h\" -DMPICH_SKIP_MPICXX=1 -DOMPI_SKIP_MPICXX=1 -DTTG_EXECUTABLE=1 -DTTG_HAS_LIBUNWIND -DTTG_SERIALIZATION_SUPPORTS_BOOST=1 -DTTG_USE_PARSEC=1 -I../ttg -I_deps/madness-build -I_deps/madness-src -I_deps/madness-src/src -I_deps/madness-build/src -I_deps/madness-build/src/madness/world -I_deps/madness-src/src/madness/world -isystem /home/joseph/TTG/parsec_ttg/build/install/include -O3 -DNDEBUG -fPIE -pthread -std=c++17 -MD -MT examples/CMakeFiles/uts-parsec.dir/uts/uts.cc.o -MF examples/CMakeFiles/uts-parsec.dir/uts/uts.cc.o.d -o examples/CMakeFiles/uts-parsec.dir/uts/uts.cc.o -c ../examples/uts/uts.cc
In file included from /usr/local/include/boost/detail/endian.hpp:9,
                 from /usr/local/include/boost/archive/impl/basic_binary_iarchive.ipp:25,
                 from ../ttg/ttg/serialization/backends/boost/archive.h:14,
                 from ../ttg/ttg/serialization/data_descriptor.h:125,
                 from ../ttg/ttg/parsec/ttg.h:28,
                 from ../ttg/ttg.h:32,
                 from ../examples/uts/uts.cc:4:
/usr/local/include/boost/predef/detail/endian_compat.h:11:161: note: #pragma message: The use of BOOST_*_ENDIAN and BOOST_BYTE_ORDER is deprecated. Please include <boost/predef/other/endian.h> and use BOOST_ENDIAN_*_BYTE instead
   11 | #pragma message("The use of BOOST_*_ENDIAN and BOOST_BYTE_ORDER is deprecated. Please include <boost/predef/other/endian.h> and use BOOST_ENDIAN_*_BYTE instead")
      |                                                                                                                                                                 ^
In file included from ../ttg/ttg/parsec/ttg.h:1743,
                 from ../ttg/ttg.h:32,
                 from ../examples/uts/uts.cc:4:
../ttg/ttg/wrap.h: In instantiation of ‘void ttg_parsec::WrapOpArgs<funcT, funcG, keyT, output_terminalsT, input_valuesT>::call_gran_func(Key&&, Tuple&&, output_terminalsT&, std::index_sequence<S ...>) [with Key = Key&; Tuple = std::tuple<std::array<char, 20>&>; long unsigned int ...S = {0}; funcT = make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&; funcG = make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&; keyT = Key; output_terminalsT = std::tuple<ttg::Out<Key, std::array<char, 20> > >; input_valuesT = {std::array<char, 20>}; std::index_sequence<S ...> = std::integer_sequence<long unsigned int, 0>]’:
../ttg/ttg/wrap.h:267:5:   required from ‘std::enable_if_t<((is_same_v<ArgsTuple, typename ttg_parsec::Op<keyT, output_terminalsT, ttg_parsec::WrapOpArgs<funcT, funcG, keyT, output_terminalsT, input_valuesT>, input_valuesT ...>::input_refs_tuple_type> && (! is_empty_tuple_v<typename ttg_parsec::Op<keyT, output_terminalsT, ttg_parsec::WrapOpArgs<funcT, funcG, keyT, output_terminalsT, input_valuesT>, input_valuesT ...>::input_refs_tuple_type>)) && (! is_void_v<Key>)), void> ttg_parsec::WrapOpArgs<funcT, funcG, keyT, output_terminalsT, input_valuesT>::gran_op(Key&&, ArgsTuple&&, output_terminalsT&) [with Key = Key&; ArgsTuple = std::tuple<std::array<char, 20>&>; funcT = make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&; funcG = make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&; keyT = Key; output_terminalsT = std::tuple<ttg::Out<Key, std::array<char, 20> > >; input_valuesT = {std::array<char, 20>}; std::enable_if_t<((is_same_v<ArgsTuple, typename ttg_parsec::Op<keyT, output_terminalsT, ttg_parsec::WrapOpArgs<funcT, funcG, keyT, output_terminalsT, input_valuesT>, input_valuesT ...>::input_refs_tuple_type> && (! is_empty_tuple_v<typename ttg_parsec::Op<keyT, output_terminalsT, ttg_parsec::WrapOpArgs<funcT, funcG, keyT, output_terminalsT, input_valuesT>, input_valuesT ...>::input_refs_tuple_type>)) && (! is_void_v<Key>)), void> = void]’
../ttg/ttg/parsec/ttg.h:507:9:   required from ‘void ttg_parsec::Op<keyT, output_terminalsT, derivedT, input_valueTs>::gran_op(Args&& ...) [with ttg::ExecutionSpace Space = ttg::ExecutionSpace::Host; Args = {Key&, std::tuple<std::array<char, 20>&>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&}; keyT = Key; output_terminalsT = std::tuple<ttg::Out<Key, std::array<char, 20> > >; derivedT = ttg_parsec::WrapOpArgs<make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, Key, std::tuple<ttg::Out<Key, std::array<char, 20> > >, std::array<char, 20> >; input_valueTs = {std::array<char, 20>}]’
../ttg/ttg/parsec/ttg.h:574:9:   required from ‘static void ttg_parsec::Op<keyT, output_terminalsT, derivedT, input_valueTs>::static_gran_op(parsec_task_t*) [with ttg::ExecutionSpace Space = ttg::ExecutionSpace::Host; keyT = Key; output_terminalsT = std::tuple<ttg::Out<Key, std::array<char, 20> > >; derivedT = ttg_parsec::WrapOpArgs<make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, Key, std::tuple<ttg::Out<Key, std::array<char, 20> > >, std::array<char, 20> >; input_valueTs = {std::array<char, 20>}; parsec_task_t = parsec_task_s]’
../ttg/ttg/parsec/ttg.h:862:13:   required from ‘void ttg_parsec::Op<keyT, output_terminalsT, derivedT, input_valueTs>::set_arg_local_impl(const Key&, Value&&) [with long unsigned int i = 0; Key = Key; Value = std::array<char, 20>; keyT = Key; output_terminalsT = std::tuple<ttg::Out<Key, std::array<char, 20> > >; derivedT = ttg_parsec::WrapOpArgs<make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, Key, std::tuple<ttg::Out<Key, std::array<char, 20> > >, std::array<char, 20> >; input_valueTs = {std::array<char, 20>}]’
../ttg/ttg/parsec/ttg.h:798:7:   required from ‘std::enable_if_t<((! is_void_v<Key>) && (! is_void_v<typename std::decay<Value>::type>)), void> ttg_parsec::Op<keyT, output_terminalsT, derivedT, input_valueTs>::set_arg_local(const Key&, Value&&) [with long unsigned int i = 0; Key = Key; Value = std::array<char, 20>; keyT = Key; output_terminalsT = std::tuple<ttg::Out<Key, std::array<char, 20> > >; derivedT = ttg_parsec::WrapOpArgs<make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, Key, std::tuple<ttg::Out<Key, std::array<char, 20> > >, std::array<char, 20> >; input_valueTs = {std::array<char, 20>}; std::enable_if_t<((! is_void_v<Key>) && (! is_void_v<typename std::decay<Value>::type>)), void> = void]’
../ttg/ttg/parsec/ttg.h:986:11:   [ skipping 5 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
../ttg/ttg/parsec/ttg.h:1584:76:   required from ‘ttg_parsec::Op<keyT, output_terminalsT, derivedT, input_valueTs>::Op(const input_edges_type&, const output_edges_type&, const string&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<std::__cxx11::basic_string<char> >&, ttg::World, keymapT&&) [with keymapT = ttg::detail::default_keymap<Key>; keyT = Key; output_terminalsT = std::tuple<ttg::Out<Key, std::array<char, 20> > >; derivedT = ttg_parsec::WrapOpArgs<make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, Key, std::tuple<ttg::Out<Key, std::array<char, 20> > >, std::array<char, 20> >; input_valueTs = {std::array<char, 20>}; ttg_parsec::Op<keyT, output_terminalsT, derivedT, input_valueTs>::input_edges_type = std::tuple<ttg::Edge<Key, std::array<char, 20> > >; ttg_parsec::Op<keyT, output_terminalsT, derivedT, input_valueTs>::output_edges_type = std::tuple<ttg::Edge<Key, std::array<char, 20> > >; std::string = std::__cxx11::basic_string<char>]’
../ttg/ttg/parsec/ttg.h:1592:113:   required from ‘ttg_parsec::Op<keyT, output_terminalsT, derivedT, input_valueTs>::Op(const input_edges_type&, const output_edges_type&, const string&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<std::__cxx11::basic_string<char> >&, keymapT&&) [with keymapT = ttg::detail::default_keymap<Key>; keyT = Key; output_terminalsT = std::tuple<ttg::Out<Key, std::array<char, 20> > >; derivedT = ttg_parsec::WrapOpArgs<make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, Key, std::tuple<ttg::Out<Key, std::array<char, 20> > >, std::array<char, 20> >; input_valueTs = {std::array<char, 20>}; ttg_parsec::Op<keyT, output_terminalsT, derivedT, input_valueTs>::input_edges_type = std::tuple<ttg::Edge<Key, std::array<char, 20> > >; ttg_parsec::Op<keyT, output_terminalsT, derivedT, input_valueTs>::output_edges_type = std::tuple<ttg::Edge<Key, std::array<char, 20> > >; std::string = std::__cxx11::basic_string<char>]’
../ttg/ttg/wrap.h:205:95:   required from ‘ttg_parsec::WrapOpArgs<funcT, funcG, keyT, output_terminalsT, input_valuesT>::WrapOpArgs(funcT_&&, funcG_&&, const input_edges_type&, const typename ttg_parsec::WrapOpArgs<funcT, funcG, keyT, output_terminalsT, input_valuesT>::baseT::output_edges_type&, const string&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<std::__cxx11::basic_string<char> >&) [with funcT_ = make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&; funcG_ = make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&; funcT = make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&; funcG = make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&; keyT = Key; output_terminalsT = std::tuple<ttg::Out<Key, std::array<char, 20> > >; input_valuesT = {std::array<char, 20>}; ttg_parsec::WrapOpArgs<funcT, funcG, keyT, output_terminalsT, input_valuesT>::input_edges_type = std::tuple<ttg::Edge<Key, std::array<char, 20> > >; typename ttg_parsec::WrapOpArgs<funcT, funcG, keyT, output_terminalsT, input_valuesT>::baseT::output_edges_type = std::tuple<ttg::Edge<Key, std::array<char, 20> > >; std::string = std::__cxx11::basic_string<char>]’
/usr/include/c++/9/bits/unique_ptr.h:857:30:   required from ‘typename std::_MakeUniq<_Tp>::__single_object std::make_unique(_Args&& ...) [with _Tp = ttg_parsec::WrapOpArgs<make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, Key, std::tuple<ttg::Out<Key, std::array<char, 20> > >, std::array<char, 20> >; _Args = {make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, const std::tuple<ttg::Edge<Key, std::array<char, 20> > >&, const std::tuple<ttg::Edge<Key, std::array<char, 20> > >&, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, const std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >&, const std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >&}; typename std::_MakeUniq<_Tp>::__single_object = std::unique_ptr<ttg_parsec::WrapOpArgs<make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, Key, std::tuple<ttg::Out<Key, std::array<char, 20> > >, std::array<char, 20> >, std::default_delete<ttg_parsec::WrapOpArgs<make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&, Key, std::tuple<ttg::Out<Key, std::array<char, 20> > >, std::array<char, 20> > > >]’
../ttg/ttg/wrap.h:445:33:   required from ‘auto ttg_parsec::wrapG(funcT&&, funcG&&, const std::tuple<ttg::Edge<keyT, input_edge_valuesT>...>&, const std::tuple<input_valuesT ...>&, const string&, const std::vector<std::__cxx11::basic_string<char> >&, const std::vector<std::__cxx11::basic_string<char> >&) [with keyT = Key; funcT = make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&; funcG = make_node(ttg::Edge<Key, std::array<char, 20> >&)::<lambda(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>&; input_edge_valuesT = {std::array<char, 20>}; output_edgesT = {ttg::Edge<Key, std::array<char, 20> >}; std::string = std::__cxx11::basic_string<char>]’
../examples/uts/uts.cc:143:108:   required from here
../ttg/ttg/wrap.h:152:5: error: no match for call to ‘(std::function<void(const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)>) (Key&, std::array<char, 20>, std::tuple<ttg::Out<Key, std::array<char, 20> > >&)’
  152 |     gran_func(std::forward<Key>(key),
      |     ^~~~~~~~~
In file included from /usr/include/c++/9/future:48,
                 from ../ttg/ttg/parsec/fwd.h:6,
                 from ../ttg/ttg/fwd.h:35,
                 from ../ttg/ttg.h:4,
                 from ../examples/uts/uts.cc:4:
/usr/include/c++/9/bits/std_function.h:683:5: note: candidate: ‘_Res std::function<_Res(_ArgTypes ...)>::operator()(_ArgTypes ...) const [with _Res = void; _ArgTypes = {const Key&, std::tuple<ttg::Out<Key, std::array<char, 20> > >&}]’
  683 |     function<_Res(_ArgTypes...)>::
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/9/bits/std_function.h:683:5: note:   candidate expects 2 arguments, 3 provided
ninja: build stopped: subcommand failed.
